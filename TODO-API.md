# Overloads Policy
- `byte` (required)
- `char` (required)
- `Rune` (required)
- `U8String` (required)
- `ReadOnlySpan<byte>` (required)
- `ReadOnlySpan<char>` / `string` (optional)
- `SearchValues<byte>` (optional)

# Validation Policy
- `ReadOnlySpan<byte>`: Always
- `string` / `ReadOnlySpan<char>`: Never
- `char` : Disallow surrogates
- `byte`: Always
- `Rune`: Never
- `U8String`: Conditional, on manipulation

# TODO
- [ ] Globalization
    - [ ] Investigate if it's possible to access and reuse internal ICU/NLS/Hybrid bindings. Note: 1. CoreLib seems to rely on unchanging length case folding; 2. CoreLib scans if string is ASCII only (do better: scan and convert in place, then contribute this back) and then either calls out to ASCII or invariant logic (which uses platform-specific globalization provider)
    - [x] Figure out a proper abstraction to distribute external packages that use ICU, NLS, etc. and implement appropriate U8Comparers (see U8Abstractions, U8Comparison and U8CaseConversion)
    - [x] ~~Map and allow explicit opt into using CultureInfo?~~ (comparer implementation-defined)
    - [x] Finish implementing AsciiIgnoreCase comparer
    - [x] Adopt the abstraction for .Contains, .IndexOf, etc.
- [x] IList, IEnumerable
- [ ] Format(U8InterpolatedHandler)
- [x] Comparison
    - [x] OrdinalComparer
    - [x] ~~AsciiIgnoreCaseComparer~~
    - [x] ~~OrdinalIgnoreCaseComparer~~
    - [x] ~~UnicodeNormalizedComparer (all normalization forms)~~
- [x] Runes view (IEnumerable, or stateful IList?)
    - [ ] CopyTo(span)
- [x] Chars view (same as above)
    - [ ] CopyTo(span)
    - [ ] Optimize `U8Chars.Enumerator` and contribute to dotnet/runtime
- [x] Lines view
    - [ ] CopyTo(span)
- [ ] Splitting
    - [ ] CopyTo(span)
    - [x] Split (byte, char, Rune)
    - [x] Split (`ReadOnlySpan<byte>`) - `U8RefSplit`
    - [ ] `SplitAny (byte, char, Rune, ROS, U8String, SearchValues<byte>, SearchValues<U8String>)`
    - [x] `Split<T>, SplitAny<T> where T : IEqualityComparer<U8String>`
    - [x] parametrized Split collections (all variants)
    - [x] SplitFirst (byte, char, Rune, ROS, U8String)
    - [x] SplitLast (byte, char, Rune, ROS, U8String)
    - [x] ~~EnumerateSplit? Should regular split not be eagerly computed?~~
- [ ] Comparison
    - [x] Contains (+`T where T : IU8Comparer`?)
    - [x] StartsWith
    - [x] EndsWith
    - [x] Starts/EndsWith (+ `T where T : IU8Comparer`) overloads
    - [x] IndexOf (+`T where T : IU8Comparer`?)
    - [x] LastIndexOf (+`T where T : IU8Comparer`?)
    - [x] Equals
- [ ] Manipulation
    - [x] Concat
    - [x] Join
    - [x] Trim, TrimStart, TrimEnd
    - [x] TrimAscii, TrimStartAscii, TrimEndAscii
    - [x] Replace(byte)
    - [x] Replace(...)
    - [ ] Replace(..., T comparer)
    - [ ] ReplaceAny
    - [x] ReplaceLineEndings
    - [x] Remove
    - [ ] Remove(..., T comparer)
    - [ ] RemoveAny(...)
    - [x] ~~SliceUnsafe/SubstringUnsafe (Unchecked or Unvalidated?)~~ `U8Marshal.Slice(...)`
    - [x] ToLower/ToUpper (invariant case converter not implemented yet)
    - [x] ToLowerAscii/ToUpperAscii
- [ ] CreateLossy (replaces invalid UTF-8 with U+FFFD)
- [x] TryCreate construction variants
- [x] IsLatin/IsAlphanumeric?
- [x] Construction aligned with collection literals initialization syntax and API shape (turned out to be quite useless)
- [x] `IComparable<U8String>`, `IComparable<U8String?>`
- [x] U8Marshal
    - [x] FromBytes (or CreateUnsafe/Unchecked? Rust or Go naming?)
    - [x] ~~FromAsciiChars~~
- [x] U8Slice? U8Span? (really better not to do it because spans have special recognition by the compiler)
- [x] U8Constants
    - [x] (OS-specific) NewLine
    - [x] (OS-specific) PathSeparator
    - [x] ReplacementChar
- [ ] DebuggerViewProxy
- [x] ~~Meta: improve the UX of "validate-and-move" options to construct a U8String. The implementation is really fragile to malformed UTF-8 and it is problematic to guard against it well without sacrificing a lot of performance. Therefore, it is really important not to push the users towards using the unsafe API.~~
----------------
- [ ] Extensions
    - [ ] System.Net.Http (HttpClient, HttpContent, etc.)
    - [x] System.IO (File, anything else?)
    - [ ] Streams? Pipelines?
        - [ ] U8Stream wrapper? ReadLine? Which can be applied to FileStream? The main idea is that current stream is really heavy-handed and does a lot of transcoding. There is a need for stream that would encapsulate graceful handling of advancing only to char boundaries, reading lines and streaming validation (with user-defined error handling or maybe returned OperationResult). The drawback is this adds yet another place with really large test surface area and footgun potential.
- [ ] Analyzers
    - [ ] Replace string literal comparison with a UTF-8 one
    - [ ] Replace direct for/foreach over a U8String with U8String.AsSpan()
    - [ ] Consider deallocating NativeU8String allocated in the current scope with `using var ...`
    - [ ] Call .Lines instead of .Split((byte)'\n')
    - [ ] Pass large structs by in or ref / ref readonly (autofixer: mutable splits and enumerations by ref / ref readonly, readonly - by in)
    - [ ] Replace predicate on LINQ projection/reduction with direct Contains/Count/etc. call
- [ ] Source Generators
    - [ ] Switch map trie generator to work around C# limitations