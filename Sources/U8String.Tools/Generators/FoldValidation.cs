using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace U8.Tools.Generators;

// Method types to fold validation for:
// U8String:
// - Concat
// - Join
// - Remove
// - Replace
// - ReplaceLineEndings
// - Strip(Prefix/Suffix)
// - Split, Split(First/Last)
// - Trim, Trim(Start/End)
// U8Builder:
// - Append
// - AppendLine
// - AppendLiteral
// InterpolatedU8StringHandler:
// - AppendLiteral
// - AppendFormatted

[Generator]
public class FoldValidations : ISourceGenerator
{
    // TODO: Proper impl., this is a fragile copypaste from FoldConversions that
    // should do for now but needs to be rewritten into something decent.
    record ValidationLocation(
        string MethodName,
        string ReturnType,
        int ArgumentCount,
        string Path,
        int Line,
        int Character);

    public void Initialize(GeneratorInitializationContext context) { }

    public void Execute(GeneratorExecutionContext context)
    {
        var compilation = context.Compilation;
        var validations = new List<ValidationLocation>();

        foreach (var syntaxTree in compilation.SyntaxTrees)
        {
            var semanticModel = compilation
                .GetSemanticModel(syntaxTree);

            var invocations = syntaxTree
                .GetRoot()
                .DescendantNodes()
                .OfType<InvocationExpressionSyntax>();
                
            validations.AddRange(EnumerateValidations(semanticModel, invocations));
        }

        var source = new StringBuilder().Append("""
            // <auto-generated />
            using global::System;
            using global::System.Runtime.CompilerServices;
            using global::U8;
            using global::U8.InteropServices;
            using global::U8.Primitives;

            #pragma warning disable CS9113
            namespace System.Runtime.CompilerServices
            {
                [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
                file class InterceptsLocationAttribute(string filePath, int line, int character) : Attribute;
            }
            #pragma warning restore CS9113

            namespace U8.Generated
            {
                file static class U8SkipValidation
                {
            """);

        foreach (var validation in validations)
        {
            source.AppendLine();

            var normalizedPath = compilation.NormalizePath(validation.Path);
            if (normalizedPath is null or []) continue;

            var argsInExpr = validation.ArgumentCount switch
            {
                1 => "ReadOnlySpan<byte> value",
                2 => "ReadOnlySpan<byte> arg1, ReadOnlySpan<byte> arg2",
                _ => null
            };

            var argsCallExpr = validation.ArgumentCount switch
            {
                1 => "value",
                2 => "arg1, arg2",
                _ => null
            };

            if (argsInExpr is null || argsCallExpr is null) continue;

            var guid = Guid.NewGuid().ToString("N");
            source.AppendLine($$"""
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    [System.Runtime.CompilerServices.InterceptsLocation(@"{{normalizedPath}}", line: {{validation.Line}}, character: {{validation.Character}})]
                    public static {{validation.ReturnType}} _{{guid}}(in this U8String source, {{argsInExpr}}) => U8Unchecked.{{validation.MethodName}}(source, {{argsCallExpr}});
            """);
        }

        source.Append("""
                }
            }
            """);
#pragma warning disable RS1035
        File.WriteAllText("/Users/arseniy/Code/GitHub/U8String/Sources/U8String.Tools/Generators/validation.log", source.ToString());
        context.AddSource("U8SkipValidation.g.cs", source.ToString());
    }

    static IEnumerable<ValidationLocation> EnumerateValidations(
        SemanticModel model, IEnumerable<InvocationExpressionSyntax> invocations)
    {
        foreach (var invocation in invocations)
        {
            var symbolInfo = model.GetSymbolInfo(invocation);
            if (symbolInfo.Symbol is IMethodSymbol methodSymbol
                && CallContainsValidation(methodSymbol)
                && invocation.ArgumentList.Arguments is { Count: 1 or 2 } args)
            {
                if (args.All(arg => arg.Expression.IsKind(SyntaxKind.Utf8StringLiteralExpression)))
                {
                    var lineSpan = invocation.GetLocation().GetLineSpan();
                    if (!lineSpan.IsValid) continue;

                    var position = lineSpan.StartLinePosition;
                    var offset = invocation.Expression.Span.Length - methodSymbol.Name.Length;

                    yield return new(
                        methodSymbol.Name,
                        methodSymbol.ReturnType.Name,
                        args.Count,
                        lineSpan.Path,
                        position.Line + 1,
                        position.Character + offset + 1);
                }
            }
        }
    }

    static bool CallContainsValidation(IMethodSymbol methodSymbol)
    {
        if (methodSymbol.ContainingAssembly.Name != "U8String")
        {
            return false;
        }

        var containingType = methodSymbol.ContainingType.Name;
        var methodName = methodSymbol.Name;

        return (containingType, methodName) switch
        {
            ("U8String", "Remove") or
            ("U8String", "Replace") or
            ("U8String", "Split") or
            ("U8String", "SplitFirst") or
            ("U8String", "SplitLast") or
            ("U8String", "Strip") or
            ("U8String", "StripPrefix") or
            ("U8String", "StripSuffix") => true,

            _ => false
        };
    }
}
