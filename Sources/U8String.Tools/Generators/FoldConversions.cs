using System.Buffers.Text;
using System.Globalization;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

#pragma warning disable RCS1197 // Optimize StringBuilder.Append/AppendLine call. Why: doesn't work well with generated strings
namespace U8.Tools.Generators;

[Generator]
public class FoldConversions : ISourceGenerator
{
    record Conversion(
        int Line,
        int Character,
        SyntaxKind ConversionKind,
        string Value);

    readonly static UTF8Encoding UTF8 = new(
        encoderShouldEmitUTF8Identifier: false,
        throwOnInvalidBytes: true);

    public void Initialize(GeneratorInitializationContext context) { }

    // TODO: Port to F# if possible, or not
    public void Execute(GeneratorExecutionContext context)
    {
        var files = new Dictionary<string, List<Conversion>>();
        var compilation = context.Compilation;

        foreach (var syntaxTree in compilation.SyntaxTrees)
        {
            var semanticModel = compilation
                .GetSemanticModel(syntaxTree);

            var invocations = syntaxTree
                .GetRoot()
                .DescendantNodes()
                .OfType<InvocationExpressionSyntax>();

            foreach (var (location, conversion) in EnumerateConversions(semanticModel, invocations))
            {
                var fileName = GetFilePath(location.SourceTree?.FilePath, compilation);

                var conversions = files.TryGetValue(fileName, out var list)
                    ? list : files[fileName] = [];

                var line = location.GetLineSpan();
                if (!line.IsValid) continue;

                // TODO: This looks embarrassing, is there a better way?
                conversions.Add(conversion);
            }
        }

        foreach (var (file, conversions) in files)
        {
            var fileName = $"U8Literals_{Path.GetFileNameWithoutExtension(file)}.g.cs";
            var source = new StringBuilder().Append($$"""
                // <auto-generated />
                using System;
                using global::U8;
                using global::U8.InteropServices;

                #pragma warning disable CS9113
                namespace System.Runtime.CompilerServices
                {
                    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
                    file class InterceptsLocationAttribute(string filePath, int line, int character) : Attribute;
                }
                #pragma warning restore CS9113

                namespace U8.Generated
                {
                    file static class {{fileName[..^5]}}
                    {
                """);

            foreach (var conversion in conversions)
            {
                var utf16 = conversion.Value;
                if (utf16 is null or []) continue;

                var nullTerminate = utf16[^1] != 0;

                byte[] bytes;
                try
                {
                    bytes = UTF8.GetBytes(utf16);
                }
                catch
                {
                    continue;
                }

                var literalName = $"_u8literal_{conversion.Line}_{conversion.Character}";
                var literalAccessor = $"GetU8Literal_{conversion.Line}_{conversion.Character}";
                var byteLiteral = string.Join(",",
                    (nullTerminate ? bytes.Append((byte)0) : bytes).Select(b => b.ToString(CultureInfo.InvariantCulture)));

                source.Append($$"""
                        
                        static readonly byte[] {{literalName}} = new byte[] {{{byteLiteral}}};
                        [System.Runtime.CompilerServices.InterceptsLocation(@"{{file}}", line: {{conversion.Line}}, character: {{conversion.Character}})]
                        internal static U8String {{literalAccessor}}(string _) => U8Marshal.CreateUnsafe({{literalName}}, 0, {{bytes.Length}});

                """);
            }

            source.Append("""
                    }
                }
                """);

            context.AddSource(fileName, source.ToString());
        }
    }

    static IEnumerable<(Location location, Conversion conversion)> EnumerateConversions(
        SemanticModel model, IEnumerable<InvocationExpressionSyntax> invocations)
    {
        foreach (var invocation in invocations)
        {
            var symbolInfo = model.GetSymbolInfo(invocation);
            if (symbolInfo.Symbol is IMethodSymbol methodSymbol
                && IsConversionCall(methodSymbol)
                && invocation.ArgumentList.Arguments is [var argument])
            {
                var constant = model.GetConstantValue(argument.Expression);
                if (constant is { HasValue: true, Value: string constantValue })
                {
                    var lineSpan = invocation.GetLocation().GetLineSpan();
                    if (!lineSpan.IsValid) continue;

                    var position = lineSpan.StartLinePosition;
                    var line = position.Line + 1;
                    var offset = invocation.Expression.Span.Length - methodSymbol.Name.Length;
                    var character = position.Character + offset + 1;

                    var literalType = argument.Expression.Kind();

                    yield return (
                        invocation.GetLocation(),
                        new(line, character, literalType, constantValue));
                }
            }
        }
    }

    static bool IsConversionCall(IMethodSymbol methodSymbol)
    {
        var containingType = methodSymbol.ContainingType.Name;
        var methodName = methodSymbol.Name;

        return (containingType, methodName) switch
        {
            ("U8String", "Create") or
            ("U8String", "CreateLossy") or
            ("U8String", "CreateInterned") or
            ("U8String", "FromAscii") or
            ("U8String", "FromLiteral") => true,

            ("Syntax", "u8") => true,

            _ => false
        };
    }

    static string GetFilePath(string? path, Compilation compilation)
    {
        return path != null
            ? compilation.Options.SourceReferenceResolver?.NormalizePath(path, baseFilePath: null) ?? path
            : string.Empty;
    }
}
