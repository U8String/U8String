using System.Text;

using Microsoft.CodeAnalysis;

using U8.Tools.Generators.OptimizationScopes;

namespace U8.Tools.Generators;

// TODO: At some point, this will need some form of AST to allow
// optimization stages feed into each other before emitting the final
// code. This is also a requirement to eagerly detect and resolve
// interception conflicts which are bound to happen given how that
// the entirety of U8String is metric tons of overloads upon overloads.

// Stages:
// - FoldValidation | FoldConversion
// - Unroll(Comparison/Conversion/Copy)
// - SpecializeDispatch
// - DetectImports
// - EmitDependencies
// - EmitInterceptors

// State:
// - EmitDependencies
// - InterceptedLocations
//   - TrackedArguments
// - ConvertedLiterals

[Generator]
sealed class Optimizer : ISourceGenerator
{
    readonly IOptimizationScope[] Optimizations = [new FoldConversions(), new FoldValidation()];

    public void Initialize(GeneratorInitializationContext _) { }

    public void Execute(GeneratorExecutionContext context)
    {
        var compilation = context.Compilation;

        foreach (var syntaxTree in compilation.SyntaxTrees)
        {
            var semanticModel = compilation
                .GetSemanticModel(syntaxTree);

            var syntaxNodes = syntaxTree
                .GetRoot()
                .DescendantNodes();

            ProcessSyntaxNodes(semanticModel, syntaxNodes);
        }

        foreach (var scope in Optimizations)
        {
            if (!scope.Interceptors.Any())
            {
                continue;
            }

            var source = EmitInterceptors(compilation, scope);

            context.AddSource($"U8{scope.Name}.g.cs", source);
        }
    }

    void ProcessSyntaxNodes(SemanticModel model, IEnumerable<SyntaxNode> nodes)
    {
        foreach (var node in nodes)
        {
            if (!model.TryGetInvocation(node, out var invocation, out var method))
            {
                continue;
            }

            foreach (var optimization in Optimizations)
            {
                if (optimization.ProcessCallsite(model, method, invocation))
                {
                    break;
                }
            }
        }
    }

    string EmitInterceptors(Compilation compilation, IOptimizationScope scope)
    {
        var source = new StringBuilder("// <auto-generated />");

        source.AppendLine();
        foreach (var import in scope.Imports)
        {
            source.AppendLine($"using global::{import};");
        }

        source.AppendLine();
        source.AppendLine("""
            #pragma warning disable CS9113
            namespace System.Runtime.CompilerServices
            {
                [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
                file class InterceptsLocationAttribute(string filePath, int line, int character) : Attribute;
            }
            #pragma warning restore CS9113
            """);

        source.AppendLine();
        source.AppendLine($$"""
            namespace U8.Generated
            {
                file static class U8{{scope.Name}}
                {
            """);

        foreach (var field in scope.Fields)
        {
            source.AppendLine($"""
                    static readonly {field};
            """);
        }

        foreach (var interceptor in scope.Interceptors)
        {
            source.AppendLine();

            // Custom attributes (like AggressiveInlining)
            foreach (var attribute in interceptor.CustomAttrs)
            {
                source.AppendLine($"""
                        [{attribute}]
                """);
            }

            // Callsite interception specifiers
            foreach (var callsite in interceptor.Callsites)
            {
                var path = compilation.NormalizePath(callsite.Path);

                source.AppendLine($"""
                        [InterceptsLocation(@"{path}", {callsite.Line}, {callsite.Character})]
                """);
            }

            // Accessibility modifiers
            source.Append("        public static ");
            source.Append(interceptor.ReturnType ?? "void");
            source.Append(' ');

            // Generic arguments
            if (interceptor.GenericArgs is not [])
            {
                source.Append($"<{string.Join(", ", interceptor.GenericArgs)}>");
            }

            // Method name
            source.Append($"__{Guid.NewGuid():N}(");

            // Instance type as a first argument (if any)
            if (interceptor.InstanceArg is not null)
            {
                source.Append(interceptor.InstanceArg);
            }

            // Arguments (if any)
            if (interceptor.Args is not [])
            {
                if (interceptor.InstanceArg is not null)
                {
                    source.Append(", ");
                }

                var args = interceptor.Args.Select((arg, i) => $"{arg} arg{i}");
                source.Append(string.Join(", ", args));
            }

            // Method signature end
            source.AppendLine(")");
            // FIXME: this has ruined formatting for multi-line bodies
            source.AppendLine($$"""
                    {
                        {{interceptor.Body}}
                    }
            """);
        }

        source.Append("""
                }
            }
            """);

        return source.ToString();
    }
}
