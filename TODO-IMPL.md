# TODO
- [ ] Contribute https://github.com/dotnet/csharplang/issues/6161 specification work
- [ ] Contribute ArraySortHelper.cs optimizations to make it able specialize on struct TComparers
- [ ] Contribute https://arxiv.org/pdf/2010.03090.pdf implementation to dotnet/runtime if applicable
- [ ] Contribute JsonWriter.WriteStringValue(bytes) optimization to dotnet/runtime (or work around it)
- [ ] Contribute IsAsciiWhitespace codegen shape to CoreLib, check out if Utf8Length can be ported too
- [ ] Contribute optimized versions of span enumerators
- [ ] Contribute optimized string case conversions and comparisons - turns out current implementation is really wasteful in most cases: performs scanning multiple times, has un-elided bounds checks, does not do vectorization, etc.
    - [ ] Invariant
    - [ ] Ordinal + .Utf8 (Ordinal.Utf8.cs)
    - [ ] Main theme: uses of Rune.DecodeFromUtf8, missed easy vectorized case folding opportunities, surrogate finding, etc.
    - [ ] Discuss code deduplication to centralize the types which "own" the knowledge and are the source of truth
- [ ] Consider Rust-like U8Searcher (or IU8Searcher) abstraction (or just U8SearchValuesSplit for now). This is to stop duplicating splitting code, because adding another split type impl. seems a bit too much
    - [ ] `U8Searcher<T>` where T is byte or char or Rune
    - [ ] `U8Searcher<T, C>` where C is IU8ContainsOperator, IU8CountOperator, IU8IndexOfOperator
    - [ ] `U8SearchValues` + `implicit operator U8SearchValues(SearchValues<byte> searcher)`
- [ ] Consider centralizing `new byte[length]` allocations to control null-termination and zeroing
- [ ] Coalesce CaseConversion and Comparison into Casing (e.g. U8Casing, U8OrdinalCasing, U8AsciiCasing)
- [x] ~~Null-terminate odd-sized arrays?~~ (relying on UB is bad idea, null-terminate normally)
- [ ] Optimize .Replace methods
- [ ] Mirror caching of certain types which cache ToString() with ConditionalWeakTable?
- [ ] Contains/IndexOf/LastIndexOf on surrogate `char`s -> instead of returning false or -1, implement (vectorized) transcoding search
- [ ] Use https://developer.arm.com/documentation/ddi0596/2020-12/SIMD-FP-Instructions/TBX--Table-vector-lookup-extension- to speed-up case conversions
- [ ] Consider `NativeU8Span` as the main unmanaged string primitive while `NativeU8String` would represent the original memory owner responsible for its lifecycle, not intended for direct interaction
- [ ] Choose scope for 1.0.0 release - there is simply too much to do
- [ ] Reconsider aggressive inlining choices in regards to top-down compiler reasoning about program state (i.e. a small callee can be inlined and then have calls to large aggressively inlined methods inside - this needs to be double-checked how .NET handles such scenario)
- [ ] Turns out that `(int)nint` cast does not "reverse-sign-extend" and produces -1 - audit the code and fix that via `int.CreateSaturating` and investigate if there's a way to improve codegen for this
- [ ] Reconsider opportunistic null-termination on U8String itself rather than having to always re-allocate
- [ ] Reconsider the choice to scan split sequences for the element count when separator is more than 1 byte long when materializing to `List<U8String>` - maybe it's a better trade-off to just keep growing the list allowing it to re-allocate? Might be fixed with InlineArray builder too
- [ ] Port InlineArray-based array builder from neuecc's https://github.com/dotnet/runtime/pull/90459
- [ ] Argument validation consistency:
    - [ ] Ensure .Contains, .IndexOf, .StartsWith, etc. can handle surrogates, specifically the Rune and char overloads
    - [x] Ensure .Concat, .Join, .Split{First,Last} reject surrogates if those produce invalid UTF-8 (double-check)
- [x] Investigate if there is a bug in AsciiUtils where Vector128 _Vectorized path is never exercised on ARM64 Preliminary: yes, it is a bug, 40% perf is left on the table for ARM64. https://github.com/dotnet/runtime/issues/89924
- [ ] Refactor internal extensions and helper methods into separate classes
- [x] ~~Look into MakeSeparatorListVectorized impl. in CoreLib and adopt its approach if applicable~~
- [x] Refactor and generalize large chunks into separate utility classes
- [ ] Optimize Split(..., U8SplitOptions)
- [x] Consider alternate eagerly-evaluated Split consisting of (byte[] source, U8Range[] offsets). Conclusion: no, but optimize CopyTo()
- [x] Consider `OriginalU8String`/`SourceU8String` or refactoring into `U8String` and `U8Slice` (I'm not a fan of this because `U8Slice` won't be backwards convertible to `U8String` and developers will just take `U8String` everywhere, leading back to the issues caused by `string` tradeoffs) Solution: not worth, focus on `ROS<byte>` as much as possible with `NativeU8String` and `NativeU8String<TAlloc>`(?) as alternatives
- [x] Optimize `Split(...).ToArray()` path - right now it loses to string.Split quite a bit on short lengths
- [x] ~~U8Info to evaluate byte and rune properties, ideally in a branchless lookup table based way~~
- [x] Consider whether overloads should take U8Comparison or CultureInfo? (i.e. IgnoreCase, UnicodeNormalized, etc.) Solution: U8Comparison
- [x] Ensure `default(U8String)` is always valid
- [x] Decide how to guard (or declare UB) methods that accept chars against surrogates
- [ ] Author exception types and messages for malformed UTF-8 (use FormatException or U8FormatException?)
- [ ] Author documentation
- [x] Reconsider the `.Lines` behavior - restrict to `\n` or `\r\n` only or all newline codepoints? +Add remarks to docs
- [ ] Investigate the exact requirements for accessing pre-converted UtF-8 values of string literals and consolidate/clean up all conversion methods
- [x] Optimize AsSpan() overloads
- [x] Consider Trim/ToUpper/LowerAscii method variants to not throw on invalid ASCII but rather omit such characters similar to what Rust's String functions do. Done: now non-ascii chars are simply ignored
- [x] Debugger View and ToString
- [x] Complete Rune counting vectorization
- [ ] Invalid sequences sanitization (specifically to remove invalid sequences, non-owned zero space glyps, etc. to interfere with popular utf8 text fingerprinting techniques)
    - [ ] Replace invalid
    - [ ] Trim invalid (and count?)
- [x] Complete char counting vectorization (does counting non-continuation bytes is sufficient to be compliant with to-Chars conversion?)
- [x] IList<byte>
- [x] Equality
- [x] Replace checked slicing with unchecked once implemented where applicable
- [x] JsonConverter
- [x] Consider whether Char8-like byte represntation is needed. Solution: not needed, use Rune and Char views.
- [x] ~~(torture)~~ Utf8 Validation. Solved by https://github.com/dotnet/runtime/issues/502
- [x] Utf8 code-point aware indexing. 
- [x] Reconsider .Unsafe namespace for U8Marshal since some methods are unsafe but .Create(byte[]) simply skips validation
- [x] Investigate why `Unsafe.As` breaks accessing `InnerOffsets` but `Unsafe.BitCast` doesn't + track https://github.com/dotnet/runtime/pull/85562

# References
https://github.com/dotnet/runtime/blob/4f9ae42d861fcb4be2fcd5d3d55d5f227d30e723/src/coreclr/src/System.Private.CoreLib/src/System/Utf8String.cs
