# TODO
- [ ] Contribute https://github.com/dotnet/csharplang/issues/6161 specification work
- [ ] Contribute ArraySortHelper.cs optimizations to make it able specialize on struct TComparers
- [ ] Contribute https://arxiv.org/pdf/2010.03090.pdf implementation to dotnet/runtime if applicable
- [ ] Contribute JsonWriter.WriteStringValue(bytes) optimization to dotnet/runtime (or work around it)
- [ ] Contribute IsAsciiWhitespace codegen shape to CoreLib, check out if Utf8Length can be ported too
- [ ] Argument validation consistency:
    - [ ] Ensure .Contains, .IndexOf, .StartsWith, etc. can handle surrogates, specifically the Rune and char overloads
    - [ ] Ensure .Concat, .Join, .Split{First,Last} reject surrogates if those produce invalid UTF-8 (double-check)
- [x] Investigate if there is a bug in AsciiUtils where Vector128 _Vectorized path is never exercised on ARM64 Preliminary: yes, it is a bug, 40% perf is left on the table for ARM64. https://github.com/dotnet/runtime/issues/89924
- [ ] Look into MakeSeparatorListVectorized impl. in CoreLib and adopt its approach if applicable
- [ ] Refactor and generalize large chunks into separate utility classes
- [x] Consider alternate eagerly-evaluated Split consisting of (byte[] source, U8Range[] offsets). Conclusion: no, but optimize CopyTo()
- [ ] Consider `OriginalU8String`/`SourceU8String` or refactoring into `U8String` and `U8Slice` (I'm not a fan of this because `U8Slice` won't be backwards convertible to `U8String` and developers will just take `U8String` everywhere, leading back to the issues caused by `string` tradeoffs)
- [ ] Optimize `Split(...).ToArray()` path - right now it loses to string.Split quite a bit on short lengths
- [x] ~~U8Info to evaluate byte and rune properties, ideally in a branchless lookup table based way~~
- [x] Consider whether overloads should take U8Comparison or CultureInfo? (i.e. IgnoreCase, UnicodeNormalized, etc.) Solution: U8Comparison
- [x] Ensure `default(U8String)` is always valid
- [ ] Implement packed count of codepoints (both charcount and match count)
- [x] Decide how to guard (or declare UB) methods that accept chars against surrogates
- [ ] Author exception types and messages for malformed UTF-8
- [ ] Author documentation
- [x] Reconsider the `.Lines` behavior - restrict to `\n` or `\r\n` only or all newline codepoints? +Add remarks to docs
- [ ] Investigate the exact requirements for accessing pre-converted UtF-8 values of string literals and consolidate/clean up all conversion methods
- [x] Optimize AsSpan() overloads
- [ ] Consider Trim/ToUpper/LowerAscii method variants to not throw on invalid ASCII but rather omit such characters similar to what Rust's String functions do
- [x] Debugger View and ToString
- [ ] Complete Rune counting vectorization
- [ ] Invalid sequences sanitization (specifically to remove invalid sequences, non-owned zero space glyps, etc. to interfere with popular utf8 text fingerprinting techniques)
    - [ ] Replace invalid
    - [ ] Trim invalid (and count?)
- [x] Complete char counting vectorization (does counting non-continuation bytes is sufficient to be compliant with to-Chars conversion?)
- [x] IList<byte>
- [x] Equality
- [x] Replace checked slicing with unchecked once implemented where applicable
- [x] JsonConverter
- [x] Consider whether Char8-like byte represntation is needed. Solution: not needed, use Rune and Char views.
- [x] ~~(torture)~~ Utf8 Validation. Solved by https://github.com/dotnet/runtime/issues/502
- [x] Utf8 code-point aware indexing. 
- [x] Reconsider .Unsafe namespace for U8Marshal since some methods are unsafe but .Create(byte[]) simply skips validation
- [x] Investigate why `Unsafe.As` breaks accessing `InnerOffsets` but `Unsafe.BitCast` doesn't + track https://github.com/dotnet/runtime/pull/85562

# References
https://github.com/dotnet/runtime/blob/4f9ae42d861fcb4be2fcd5d3d55d5f227d30e723/src/coreclr/src/System.Private.CoreLib/src/System/Utf8String.cs
